├── src/
│   ├── creational/
│   │   ├── singleton.rs
│   │   ├── factory.rs
│   │   └── builder.rs
│   ├── structural/
│   │   ├── adapter.rs
│   │   ├── decorator.rs
│   │   └── composite.rs
│   ├── behavioral/
│   │   ├── observer.rs
│   │   ├── strategy.rs
│   │   └── command.rs
│   └── lib.rs
└── Cargo.toml



## 按照难易程度,对设计模式排序

单例模式（Singleton）：
*  相对简单，用于确保一个类只有一个实例，并提供一个全局访问点。

工厂方法模式（Factory Method）：
*  介绍了抽象工厂类和具体工厂类的概念，用于创建对象而不必指定具体的类。

抽象工厂模式（Abstract Factory）：
*  更复杂一些，提供了一个接口，用于创建一系列相关或依赖对象，而不指定具体类。

建造者模式（Builder）：
*  用于创建复杂对象，通过将构建过程分解为多个步骤，逐步构建对象。

策略模式（Strategy）：
*  允许在运行时选择算法的行为，通过定义一系列可互换的算法。

观察者模式（Observer）：
*  定义了对象之间的一对多依赖关系，当一个对象改变状态时，所有依赖它的对象都会收到通知并自动更新。

装饰器模式（Decorator）：
*  动态地给对象添加行为，通过将对象包装在装饰器类中来扩展其功能。

适配器模式（Adapter）：
*  允许将一个类的接口转换成客户希望的另一个接口，使得原本接口不兼容的类可以一起工作。

组合模式（Composite）：
*  将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。
命令模式（Command）：
*  将请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化。

状态模式（State）：
*  允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。

代理模式（Proxy）：
*  为其他对象提供一种代理以控制对这个对象的访问，以实现安全或懒加载等目的。

模板方法模式（Template Method）：
*  在父类中定义算法的骨架，而将一些步骤延迟到子类中实现。

迭代器模式（Iterator）：
*  提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。

责任链模式（Chain of Responsibility）：
*  使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。